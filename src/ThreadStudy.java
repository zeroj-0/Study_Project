public class ThreadStudy {
    public static void main(String[] args) {
        /**
         * 운영체제(Operating System) : 컴퓨터 하드웨어를 사용하게 해주는 프로그램
         * 프로세스(Process) : 현재 실행되고 있는 프로그램
         * 쓰레드 : 동시에 여러가지 작업을 동시 수행할수 있게하는 것
         *     Thread클래스 상속받는 방법 : java.lang.Thread클래스를 상속받는다. 그리고 Thread가 가지고 있는 run()메소드를 오버라이딩
         *     Runnable인터페이스 구현해서 스레드 만드는 방법 : Runable 인터페이스가 가지고 있는 run()메소드를 구현
         *                                           Thread생성하고 해당 생성자에 Runable인터페이스를 구현한 클래스를 인스턴스한 것을 넣어서 Thread 객체 생성(Thread상복받지 않아서 Thread가 아님)
         *
         *        Thread 동작시 run()이 아닌 start()메소드 호출해야함.
         *
         * 쓰레드와 공유객체 : 하나의 객체를 여러개의 Thread가 사용한다는 것을 의미
         *
         * 동기 : 쓰레드가 작업이 다른 쓰레드와 조화롭게 동작한다 (다른 쓰레드가 관여할 경우 자신의 실행을 잠시 멈춘다)
         * 비동기 : 쓰레드가 다른 쓰레드에 신경 쓰지않고 그냥 자기 할일만 한다
         *
         * 동기화 메소드와 동기화 블록 : 공유객체가 가진 메소드를 동시에 호출 되지 않도록 하는 방법(= multi-thread로 동시접근되는것을 막음)
         *                       메소드 앞에 synchronized를 붙힘. 여러개의 쓰레드들이 공유객체의 메소드를 사용할 때 메소드에 synchronized가 붙어 있을 경우 먼저 호출한 메소드가 객체의 사용권(Monitoring Lock)을 얻는다
         *                       synchronized(잠글 객체){
         *                              하나의 쓰레드만 처리되는 영역
         *                       }
         *                       실행해보면 메소드 하나가 모두 실행된 후에 다음 메소드가 실행됨. 해당 모니터링 락은 메소드 실행이 종료되거나, wait()와 같은 메소드를 만나기 전까지 유지됨.
         *                       다른 쓰레드들은 모니터링 락을 놓을때까지 대기한다.
         *                       synchronized를 붙히지 않은 메소드들은 synchronized메소드를 실행하면서 모니터링 락을 획득했다 하더라도, 그것과 상관없이 실행
         *                       메소드의 코드가 길어지면, 마지막에 대기하는 쓰레드가 너무 오래 기다리는것을 막기위해서 메소드에 synchronized를 붙이지 않고, 문제가 있을것 같은 부분만 synchronized블록 사용
         *
         * 쓰레드와 상태제어 : 쓰레드는 start()메소드로 하여금 실행가능상태인 Runnable과 실행상태인 Running상태를 왔다갔다 한다.
         *                실행되는 쓰레드 안에서 Thread.sleep()이나 Object Class가 가지고 있는 wait()메소드가 호출이 되면 쓰레드는 Blocked상태가 된다.
         *                sleep()메소드는 특정시간이 지나면 자기 스스로 blocked상태를 빠져나와 runnable이나 running상태가 된다
         *                wait()메소드는 다른쓰레드가 notify()나 notifyAll()메소드를 호출하기 전에는 blocked상태가 해제되지 않음
         *                            호출되면 모니터링 락을 놓게 됨.그래서 대기중인 다른 메소드가 실행됨.
         *                쓰레드의 run메소드가 종료되면, 쓰레드는 종료된다. 즉 Dead상태가 된다.
         *                Thread의 yeild()메소드가 호출되면 해당 쓰레드는 다른 쓰레드에게 자원을 양보하게 된다. --> 다른 스레드가 좀 더 빠르게 실행되게 할 수 있음
         *                Thread가 가지고 있는 join메소드를 호출하게 되면 해당 쓰레드가 종료될 때까지 대기하게 된다.
         *
         * join() Method : 쓰레드가 멈출때까지 기다리게 한다. ( = 쓰레드가 멈출때까지 다음 명령 기다리게 함)
         *
         * wait(),notify() Method : 이 둘은 동기화된 블록안에서 사용해야함. wait를 만나게 되면 해당 쓰레드는 항상 객체의 모니터링 락에 대한 권한을 가지고 있다면 모니터링 락의 권한을 놓고 대기함
         *                          notify()를 만나면서 wait에서 깨어나게됨
         *
         * 데몬 쓰레드(Daemon Thread) : 보통 리눅스와 같은 유닉스계열의 운영체제에서 백그라운드로 동작하는 프로그램
         *                           => 쓰레드에 데몬설정하면됨. 이 쓰레드는 자바프로그램을 만들 때 백그라운드에서 특별한 작업을 처리하게 하는 용도로 만든다
         *                           데몬쓰레드는 일반 쓰레드(main 등)가 모두 종료되면 강제적으로 종료되는 특징 가짐
         *
         * 람다식(= 익명 메소드) : 인터페이스 증 메소드 하나만 가지고 있는 인터페이스를 함수형 인터페이스라고 함
         *                    Runnable인터페이스의 경우 run()메소드 하나만 가짐 => 함수형 인터페이스
         *                    객체자체를 직접 생성할 필요 없음.
         *                    '() -> {.. 구현할 부분..}' : 람다식
         *
         *
         * 자바는 메소드만 매개변수로 전달할 수 없고, 인스턴스만 전달 할 수 있기 때문에 객체를 만들고 매개변수로 전달해야함. 이런부분을 해결하기 위한 것이 람다표현식..!
         * 람다식 기본문법 : '(매개변수목록) -> {실행문}'
         * JVM이 람다식을 보고 무엇에 해당되는 인터페이스인지 추론하고 그 인터페이스를 구현한 것이 와야 하는 것을 알게 되고 람다식이 인터페이스를 구현하는 객체로 자동으로 만들어 매개변수로 넣어준다.
         *
         *
         *
         *
         *
         *
         *
         */
    }
}
