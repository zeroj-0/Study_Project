public class StudyClass {
    public static void main(String[] args) {
        /**
         * 자바의 변수타입 : 기본형 타입 / 참조형 타입
         * 참조타입 : 기본형 타입을 제외한 모든 타입. 클래스도 참조타입
         *          (기본형 타입 : 논리형, 문자형, 정수형, 실수형)
         *          ex) String str = new String("hello");
         *                --> new 다음에 생성자를 이용하여 메모리에 객체를 만들라는 명령
         *                --> 메모리에 올라간 인스턴스를 가리키는 변수, 참조하는 변수, 레퍼런스하는 변수가 str
         *                --> str이라는 변수에는 메모리의 위치 값이 저장되는 것!!!
         * 인스턴스 : 메모리에 올라간 객체를 가리킴.
         *          new라는 키워드를 이용해 객체를 메모리에 올려줌
         *          new연산자를 이용하여 인스턴스를 만들면 인스턴스는 무조건 새롭게 만들어짐
         *
         * 클래스 : 객체를 만들기 위해 반드시 클래스를 먼저 만들어야함. 클래스는 객체를 만들기 위한 일종의 틀
         *        구성 멤버에는 필드(field). 생성자(constructor), 메소드(method) => 생략되거나 복수 개 작성 가능
         *        필드(=> 속성) : 객체의 데이터가 저장되는 곳
         *                      객체의 고유 데이터, 객체의 현재 상태 데이터를 저장
         *                      생성자와 메소드 중괄호 내부에 선언된 것은 모두 local변수가 됨
         *                      클래스 내부의 생성자나 메소드에서 사용할 경우 단순히 필드 이름으로 읽고 변경하면 되지만, 외부에서 사용할 경우 클래스로부터 객체를 생성한 뒤 필드를 사용해야함.
         *                      참조 변수 다음에 나오는 .은 참조변수가 참조하는 객체가 가지고 있는 것을 사용할 때 사용
         *        생성자 : 객체 생성 시 초기화 역할 담당
         *               모든 클래스는 인스턴스화 될때 생성자 사용
         *               리턴타입 없음. 프로그래머스가 만들지 않으면 매개변수가 없는 생성자가 컴파일할 때 자동으로 만들어짐
         *               매개변수가 없는 생성자를 기본생성자라 함.
         *               this : 현재 객체, 자기 자신을 나타냄
         *                      클래스안에서 자기 자신이 가지고 있는 메소드를 사용할때도 this.메소드명()으로 호출할 수 있음
         *                      this.name(필드) = name(매개변수);
         *        메소드 : 객체의 동작에 해당하는 실행 블록
         *               입력값이 있고 그 입력값을 받아서 무언가 한 다음 결과를 도출해 내는 수학의 함수와 비슷한 개념 !
         *               클래스가 가지고 있는 기능. 클래스안에서 선언됨
         *               이때의 입력값을 매개변수라하고 결과값을 return값이라고 함
         *               return값 없는 메소드의 리턴타입 : void
         *               return값 있는 메소드의 리턴타입 : return값의 타입
         *                  - 인자(Argument) : 어떤 함수를 호출시에 전달되는 값 의미
         *                  - 매개변수(Parameter) : 그 전달된 인자를 받아들이는 변수 의미
         *        public class 클래스명 {
         *              // 필드
         *              int 필드명;
         *              //생성자
         *              클래스명(){ ...
         *              }
         *              //메소드
         *              리턴타입 메소드명(매개변수 선언(메소드가 실행할 때 칠요한 데이터를 받기 위한 변수), ...){ ...
         *              }
         *        }
         * String클래스 : 문자열을 표현하는 자바에서 가장 많이 사용하는 클래스
         *              String은 다른 클래스와 다르게 new를 사용하지 않고 사용가능. 메모리 아끼고 싶다면 new사용하지 않고 사용하는것이 좋다
         *              불변 클래스. 인스턴스가 될때 가지고 있던 값을 나중에 수정할 수 없다.
         *              String 메소드 중 String을 반환하는 메소드는 모두 새로운 String을 생성해서 반환
         *
         * static  : static한 필드(필드 앞에 static키워드 붙임), static한 메소드는 클래스가 인스턴스화 되지 않아도 사용 가능
         *           static한 메소드에서는 static하지 않은 필드 사용 불가능
         *           static하게 선언된 변수는 값을 저장할 수 있는 공간이 하나만 생성. 따라서 인스턴스가 여러개 생성되어도 static한 변수는 하나
         *           static한 필드를 클래스 변수 => 클래스명.변수명 으로 사용하는 것이 더 바람
         *
         * 오버로딩(overloading) : 매개변수의 유형과 개수를 다르게 하여 같은 이름의 메소드를 여러개 가질 수 있게 하는 기술
         *                      메소드 오버로딩은 매개변수 부분이 달라야 함
         *                      생성자 오버로딩은 생성자의 매개변수의 유형과 개수가 다르게 하여 같은 이름의 생성자를 여러개 가질 수 있음
         *                                   매개변수의 수와 타입이 다르다면 여러개의 생성자를 선언할 수 있다.
         *
         * 오버라이딩(overriding) : 부모가 가지고 있는 메소드와 똑같은 모양의 메소드를 자식이 가지고 있는 것.
         *                       즉, 오버라이딩이란 메소드를 재정의 하는 것.
         *                       항상 자식클래스에서 정의된 메소드가 호출
         *
         * 상속 : 부모가 가진 것을 자식에게 물려주는 것을 의미
         *       클래스 이름 뒤에 extends 키워드 적고 부모클래스 이름을 적게 되면 부모 클래스가 가지고 있는 것을 상속받을 수 있다.
         *       부모클래스는 자식클래스의 영향을 받지 않음
         *
         * 접근 제한자 : 클래스 내에서 멤버의 접근을 제한하는 역할
         *            public - 어떤 클래스든 접근할 수 있다는 것을 의미
         *            protected - 자기 자신, 같은 패키지, 서로 다른 패키지다 하더라도 상속받은 자식 클래스에서는 접근할수 있다는 것을 의미
         *            private - 자기 자신만 접근할 수 있다는 것을 의미
         *            default - 접근제한자를 적지 않으면 dafault접근 지정자. 자기자신과 같은 패키지에서만 접근할 수 있다는 것을 의미
         *
         * 추상클래스 : 구체적이지 않은 클래스 의미.
         *           클래스 앞에 abstract키워드 이용하여 정의
         *           미완성의 추상메소드를 포함할 수 있다. (추상메소드 : 내용이 없는 메소드. 즉, 구현되지 않은 메소드. 리턴타입 앞에 abstract라는 키워드 붙여야함)
         *           추상 클래스는 인스턴스를 생성할 수 없다.
         *           추상 클래스를 상속받은 클래스는 추상클래스가 갖고 있는 추상메소드를 반드시 구현해야함. 구현하지 않으면 해당 클래스도 추상 클래스가 됨
         *
         * 인터페이스 : 서로 관계가 없는 물체들이 상호 작용을 하기 위해서 사용하는 장치나 시스템
         *           추상메소드와 상수를 정의할 수 있다. 인터페이스에서 정의된 메소드는 모두 추상 메소드. 변수선언시 상수로 바뀜
         *           사용할 시 인터페이스를 구현하는 클래스에서 implements 키워드 사용
         *           인터페이스가 가지고 있는 메소드를 하나라도 구현하지 않는다면 해당 클래스는 추상클래스(인스턴스 만들 수 없음)
         *           참조변수 타입으로 인터페이스를 사용할 수 있다. 이 경우 인터페이스가 가지고 있는 메소드만 사용 가능
         *           다중 상속 가능!!!! 인터페이스 메소드에 실행문쓰는 순간 오류남
         *           하지만 default키워드로 선언되면 메소드가 구현가능해진다. 이를 구현하는 클래스는 default메소드를 오버라이딩 할 수 있다.
         *           인터페이스가 변경이 되면, 인터페이스를 구현하는 모든 클래스들이 해당 메소드를 구현해야하는 문제 => 인터페이스에 메소드를 구현해 놓을 수 있도록 한다
         *           인터페이스에 static메소드를 선언함으로써, 안터페이스를 이용하여 간단한 기능을 가지는 유틸리티성 인터페이스를 만들 수 있다
         *
         *
         * super : class가 인스턴스화 될때 생성자가 실행되면서 객체의 초기화를 함. 그때 자신의 생성자만 실행이 되는 것이 아니고, 부모의 생성자부터 실행된다.
         *         자신을 가리키는 키워드가 this라면 부모들 가리키는 키워드는 super
         *         super()는 부모의 생성자를 의미
         *         super키워드는 자식에서 부모의 메소드나 필드를 사용할 때도 사용
         *
         * 클래스 형변환 : 부모타입으로 자식객체를 참조하게 되면 부모가 가지고 있는 메소드만 사용할 수 있다. 자식객체가 가지고 있는 메소드나 속성을 사용하고 싶다면 형변환 해야한다.
         *             부모클래스 부모객체명1 = new 자식클래스(); --> 인스턴스. 부모가 가지고 있는 메소드만 사용가능
         *             자식클래스 객체명2 = (자식클래스명)부모객체명1; --> 부모타입을 자식타입으로 형변환
         *             객체들 끼리도 형변환가능 ! but 상속관계 있었을 때만 가능
         *             부모타입의 객체를 자식타입으로 참조하게 할때는 명시적으로 형변환 해주어야 한다. 단, 이럴때는 부모가 참조하는 인스턴스가 형변환 하려는 자식타입일때만 가능
         *
         * 내부 클래스 : 클래스 안에 선언된 클래스
         *      1) 중첩클래스(or 인스턴스 클래스) : 필드선언하는 위치에 선언된 경우
         *                                  public class InnerExam1{
         *                                      class Cal{
         *                                          int value = 0;
         *                                          public void plus(){
         *                                              value++;
         *                                          }
         *                                      }
         *
         *                                      public static void main(String args[]){
         *                                          InnerExam1 t = new InnerExam1(); //밖의 InnerExam1의 객체 만듬
         *                                          InnerExam1.Cal cal = t.new Cal(); // Cal객체 생성한 후 사용
         *                                          cal.plus();
         *                                          System.out.println(cal.value);
         *                                      }
         *                                  }
         *      2) 정적 중첩 클래스(or static 클래스) : 내부 클래스가 static으로 정의된 경우. 필드 선언할 때 스태틱한 필드로 선언한 것과 같다.
         *                                        public class InnerExam2{
         *                                              static class Cal{
         *                                                  int value = 0;
         *                                                  public void plus(){
         *                                                      value++;
         *                                                  }
         *                                              }
         *
         *                                              public static void main(String args[]){
         *                                                  InnerExam2.Cal cal = new InnerExam2.Cal(); //InnerExam2객체를 생설할 필요x
         *                                                  cal.plus();
         *                                                  System.out.println(cal.value);
         *                                              }
         *                                           }
         *      3) 지역 중첩 클래스(or 지역 클래스) : 메소드 안에 클래스를 선언한 경우
         *                                    public class InnerExam3{
         *                                          public void exec(){
         *                                              class Cal{
         *                                                  int value = 0;
         *                                                  public void plus(){
         *                                                      value++;
         *                                                  }
         *                                              }
         *                                              Cal cal = new Cal();
         *                                              cal.plus();
         *                                              System.out.println(cal.value);
         *                                          }
         *
         *                                          public static void main(String args[]){
         *                                              InnerExam3 t = new InnerExam3();
         *                                              t.exec();
         *                                          }
         *                                      }
         *      4) 익명 클래스 : 생성자 다음에 중괄호 열고 닫고가 나오면, 해당 생성자 이름에 해당하는 클래스를 상속받는 이름없는 객체를 만든다는 것을 뜻함
         *                    괄호 안에는 메소드를 구현하거나 메소드를 추가할수 있다. 이렇게 생성된 이름 없는 객체를 action이라는 참조변수가 참조하도록 하고, exec()메소드 호ㅜㄹ
         *                    익명 클래스를 만드는 이유는 Action을 상속받는 클래스를 만들 필요가없을 경우(이때 Action은 추상클래스)
         *                    Action을 상속받는 클래스가 해당 클래스에서만 사용되고 다른 클래스에서는 사용되지 않는 경우
         *                    public class ActionExam{
         *                          public static void main(String args[]){
         *                              Action action = new Action(){
         *                                  public void exec(){
         *                                      System.out.println("exec");
         *                                  }
         *                              };
         *                              action.exec();
         *                          }
         *                      }
         *
         * ObjectClass : 모든 클래스의 최상위 클래. 아무것도 상속받지 않으면 Object클래스 상속받음
         *               Object가 가지고 있는 메소드는 모든 클래스에서 다 사용할 수 있음
         *
         * java.lang패키지 : wrapper class(기본형 데이터 타입의 객체화를 가능하게 도와주는 클래스들), String, StringBuffer, StringBuilder, Object, System, Math, ...
         *
         * 오토박싱 : 기본타입 데이터를 객체 타입의 데이터로 자동 형변환해주는 것
         * 오토언박싱 : 오토박싱과 반대개념. 객체 타입의 데이터를 기본형 타입 데이터로 자동 형변환
         *
         * getClass()메소드 : Object가 가지는 메소드. 모든 클래스는 Object클래스 상속받음
         *                  해당 인스턴스를 만들때 사용한 클래스의 정보를 리턴.
         *                  getDeclaredMethod() 메소드 호출시 그 클래스에 대한 정보를 얻고, 정보로부터 메소드명에 대한 정보를 얻어라
         *                  ex) Method method = hello.getClass().getDeclaredMethod("hello");
         *                      if(method.isAnnotationPresent(Count100.class)) --> method가 가지는 isAnnotationPresent라는 메소드가 특정 annotation이 메소드에 적용되어 있는지 알아낼 수 있는 부분
         *                                                                         boolean형으로 return
         *
         *
         */
    }
}
